# Configuration file of the testsuite.pl
#
# Use to configure both nodes and to change default commands of the testsuite.
# Important: after each argument put ; to finish the line otherwise it will not be set and can cause errors!

# Configuration of one Node
node node1 {
  # Syntax: addr <ip>
  # IP Address of the node that is visible to the internet. If this is left undefined
  # the testsuite will not start.
  #
  # Example: addr 192.168.1.10;
  #
  addr  192.168.1.10;
  
  # Syntax: port <p>
  # The port the testsuite will try to connect to. If this is left undefined
  # the testsuite will not start.
  #
  # Example: port 4000;
  #
  port  4000; 
}

# Configuration of second Node
node node2 {
  # Syntax: addr <ip>
  # IP Address of the node that is visible to the internet. If this is left undefined
  # the testsuite will not start.
  #
  # Example: addr 192.168.1.10;
  #
  addr  192.168.1.10;
  
  # Syntax: port <p>
  # The port the testsuite will try to connect to. If this is left undefined
  # the testsuite will not start.
  #
  # Example: port 4000;
  #
  port  4000;
}

# Set of default parameters of the testsuite
defaults {
  # Syntax: timeout <n>
  # Generall timeout limit of <n> seconds for the response of the executed command.
  #
  # If this is left undefined default is to wait 0 seconds = wait forever.
  #
  # Example: timeout 20;
  #
  timeout  10;
  
  # Syntax: latency <l>
  # 
  # The maximum time/clock difference between the two agents. If it's above
  # the given value, FIXME => sync
  #
  # If this is left undefined default latency is 0.5 seconds
  #
  # Example: latency 0.05;
  #
  latency  0.1;

  # Syntax: connect_timeout <n>
  # Timeout after trying to establish a connection after <n> seconds
  #
  # If this is left undefined default is to wait 3 seconds.
  #
  # Example: connect_timeout 1;
  #
  connect_timeout 1;

  # Syntax: timeserver <ip/host>
  # If nodes are out of sync, ntpdate <ip/host> will be sent to each node.
  #
  # If no timeserver is given, the testsuite will abort instead of trying
  # to syncronize the agents.
  #
  timeserver 10.25.91.12;
}

# Set of sequence commands to be executet on the nodes. See README for detailed
# information about available commands.
seq-commands {

  # check if we are in a stable state
  if ((get 'drbdsetup /dev/drbd0 state', on node1) =~ /Unknown/) {
    VERBOSE ("trouble with drbd on agents");
    die();
  }

  cmd '/sbin/drbdadm detach {resource}', on node1;

  # simulate meta data read failures during attach
  INFO "1. Simulate local meta data read failures during attach";
  cmd set_fr, on node1;
  cmd set_md_rd, on node1;

  # attach/detach a few times (want at least one failure!
  for (my $i = 0; $i < 5; ++$i) {
    cmd '/sbin/drbdadm attach {resource}', on node1;

    sleep 2;

    if ((get state_ds, on node1) =~ /Diskless/) {
	VERBOSE ("goodness: meta data read fault fired");
    }
    else {
	# might need to wait for resync here... disable
	# faults whilst we wait
	cmd clr_fr, on node1;

	expected 'cs', state 'Connected', timeout 500;
	expected 'ds', state 'UpToDate', timeout 500;

	cmd '/sbin/drbdadm detach {resource}', on node1;

	cmd set_fr, on node1;
	cmd set_md_rd, on node1;
    }

    # everyone should be in connected state
    expected 'cs', state 'Connected', timeout 15;
  }

  cmd clr_fr, on node1;

  # simulate meta data write failures during attach
  INFO "2. Simulate local meta data write failures during attach";
  cmd set_fr, on node1;
  cmd set_md_wr, on node1;

  # attach/detach a few times (want at least one failure!
  for (my $i = 0; $i < 5; ++$i) {
    cmd '/sbin/drbdadm attach {resource}', on node1;

    sleep 2;

    if ((get state_ds, on node1) =~ /Diskless/) {
	VERBOSE ("goodness: meta data write fault fired");
    }
    else {
	# might need to wait for resync here... disable
	# faults whilst we wait
	cmd clr_fr, on node1;

	expected 'cs', state 'Connected', timeout 500;
	expected 'ds', state 'UpToDate', timeout 500;

	cmd '/sbin/drbdadm detach {resource}', on node1;

	cmd set_fr, on node1;
	cmd set_md_wr, on node1;
    }
  }

  cmd clr_fr, on node1;

  cmd '/sbin/drbdadm attach {resource}', on node1;

  # everyone should be in connected cstate, uptodate dstate
  expected 'cs', state 'Connected', timeout 15;
  expected 'ds', state 'UpToDate', timeout 15;

  # switch to primary
  cmd '/sbin/drbdadm primary {resource}', on node1;

  # Check node1 went primary...
  expected 'st', state 'Primary', timeout 15, on node1;

  # simulate meta data write failures on partner node
  INFO "3. Simulate remote meta data write failures during attach";
  cmd set_fr, on node2;
  cmd set_md_rd, on node2;

  cmd '/sbin/drbdadm detach {resource}', on node1;

  # attach/detach a few times (want to see at least one failure!
  for (my $i = 0; $i < 5; ++$i) {
    cmd '/sbin/drbdadm attach {resource}', on node1;

    sleep 2;

    if ((get state_ds, on node1) =~ /Diskless/) {
	VERBOSE ("goodness: meta data write fault fired");
    }
    else {
	# might need to wait for resync here... disable
	# faults whilst we wait
	cmd clr_fr, on node2;

	expected 'cs', state 'Connected', timeout 500;
	expected 'ds', state 'UpToDate', timeout 500;

	cmd '/sbin/drbdadm detach {resource}', on node1;

	cmd set_fr, on node2;
	cmd set_md_rd, on node2;
    }
  }

  cmd clr_fr, on node2;

  # make sure partner is attached...
  cmd '/sbin/drbdadm attach {resource}', on node2;

  # everyone should be in connected cstate, uptodate dstate
  expected 'cs', state 'Connected', timeout 500;
  expected 'ds', state 'UpToDate', timeout 500;

  # simulate read errors locally
  INFO "4. Simulate local user data read failures";
  cmd set_fr, on node1;
  cmd set_dt_rd, on node1;

  # mount file system a few times.
  for (my $i = 0; $i < 5; ++$i) {
      cmd 'mount /dev/{device} {mountpoint}', on node1;
      cmd 'umount /dev/{device}', on node1;

      sleep 2;

      # state should not change - i.e. no resync (YET! Should get resync of failed block
      # eventually)
      expected 'cs', state 'Connected', timeout 15;
  }

  cmd clr_fr, on node1;

  # simulate write errors locally
  INFO "5. Simulate local user data write failures";
  cmd set_fr, on node1;
  cmd set_dt_wr, on node1;

  # mount file system and modify - check for errors!
  for (my $i = 0; $i < 5; ++$i) {
      cmd 'mount /dev/{device} {mountpoint}', on node1;

      # create some files - should get some errors...
      cmd 'cp -f /boot/* {mountpoint}', on node1;
  
      cmd 'umount /dev/{device}', on node1;

      sleep 2;

      # state should not change - i.e. no resync (YET!)
      expected 'cs', state 'Connected', timeout 15;
  }

  cmd clr_fr, on node1;

  # simulate read errors remotely
  INFO "6. Simulate remote user data read failures";
  cmd 'drbdadm detach {resource}', on node1;

  cmd set_fr, on node2;
  cmd set_dt_rd, on node2;

  # mount file system - check for errors!
  for (my $i = 0; $i < 5; ++$i) {
      cmd 'mount /dev/{device} {mountpoint}', on node1;
      cmd 'umount /dev/{device}', on node1;

      sleep 2;

      # state should not change - i.e. no resync
      expected 'cs', state 'Connected', timeout 15;
  }

  cmd clr_fr, on node2;

  cmd 'drbdadm attach {resource}', on node1;

  # wait for resync to complete
  expected 'cs', state 'Connected', timeout 15;
  expected 'ds', state 'UpToDate', timeout 15;

  # simulate write errors remotely
  INFO "6. Simulate remote user data write failures";
  cmd set_fr, on node2;
  cmd set_dt_wr, on node2;

  for (my $i = 0; $i < 5; ++$i) {
      # mount file system - check for errors!
      cmd 'mount /dev/{device} {mountpoint}', on node1;

      # create some files - should get some errors...
      cmd 'cp -f /boot/* {mountpoint}', on node1;
  
      cmd 'umount /dev/{device}', on node1;

      sleep 2;
  }

  cmd clr_fr, on node2;
}

